function [inside_track,boundary_number] = track_constraints(x_target,y_target,N,innerBoundary,outerBoundary,boundary_number)

% constraint function h(x)>=0. It checks whether or not the target position
% is inside the track and if it is feasible, by returning 1 or -1. 
%
% Inputs:   x_target            -   coordiate x of target position
%           y_target            -   coordinate y of target position
%           N                   -   number of boundary samples
%           innerBoundary       -   matrix Nx3 - it contains the x,y,z
%                                   coordinates of the inner boundary
%                                   samples. 
%           outerBoundary       -   matrix Nx3 - it contains the x,y,z
%                                   coordinates of the outer boundary
%                                   samples. 
%           boundary_number     -   position in the inner boundary matrix
%                                   of the coordinates corresponding to the
%                                   last car position                                   
%
% Outputs:  inside_track        -   if  1 -> target position inside track
%                                   if -1 -> target position outside track
%           boundary_number     -   position in the inner boundary matrix
%                                   of the coordinates corresponding to the
%                                   last car position                                   

% initialization of variables 
inside_track = 0;

% for-cycle
% the cycle starts from boundary_number = 1, that is where the finish line
% is. then it is updated so that the car can go only in the forward
% direction
for i = boundary_number:N
   
   % selection of inner and outer boundaries' coordinates at track sample i
   innerPosition = [innerBoundary(i,1,1) innerBoundary(i,2,1)]';
   outerPosition = [outerBoundary(j,1,1) outerBoundary(j,2,1)]';
   
   % since the outer boundary doesn't always correspond to the one that has
   % the greatest coordinates, auxiliary variables are used: for each 
   % sample i, x_out and x_in, y_out and y_in are identified. 
   if innerPosition(1)>outerPosition(1)
       x_out = innerPosition(1);
       x_in =  outerPosition(1);
   else
       x_out = outerPosition(1);
       x_in  = innerPosition(1);
   end
   
   if innerPosition(2)>outerPosition(2)
       y_out = innerPosition(2);
       y_in  = outerPosition(2);
   else
       y_out = outerPosition(2);
       y_in  = innerPosition(2);
   end

   % to be inside the track, the target position must have x coordinates in
   % between x_out and x_in and y coordinates in between y_out and y_in. 
   % at the end of the for-cycle, if the target position is feasible, the
   % inside_track variable will be greater than zero. else, the target
   % position is not feasible
   if (x_target >= x_in && x_target <= x_out)
     if (y_target >= y_in && y_target <= y_out)
       inside_track = inside_track + 1;
       boundary_number = i
     end
   end
end

% output variable setting
if inside_track >= 1
    inside_track = 1;
else 
    inside_track = -1;
end

end